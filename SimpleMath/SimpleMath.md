SimpleMath

package prototype;

public class SongSimpleMath {
	static final int Z = 1; 
	public static void main(String [] args){
		short k= 32767;//如果把立即数赋值给一个变量，如果它在此变量的类型范围内，则直接按照此类型赋值给这个变量
		short k1=(short) 32768; //如果超出它类型的范围则会报错说不能从int转到short，说明系统默认把立即数视为int型，只能通过强转类赋值，但是会溢出得到此类型的最小值
		int k3=2147483647+1;   //如果是把超出int类型范围的立即数赋值给int类型变量，则会直接把溢出后的结果赋给变量，也就是最小值
		//int k4=2147483648+0;   //这里会报错说:2147483648 of type int is out of range;说明在编译时单个立即数会被检查其有效性，这里整型直接数被视为Int型所以超出范围,编译错误,只有当单个直接数通过验证,才会去通过运算符计算其结果,如果结果超出了原先单个直接数的范围,就像上例,单个直接数验证通过,但是相加后超出Int范围，发生溢出,但是不会报错，通过了编译;
	
		/////////////////////////////////////////////////////////////////////
		//注意下面的2次赋值：
		// 1： int a =2147483648+1L; 先报编译错：The literal 2147483648 of type int is out of range;
		                                //再是:Type mismatch: cannot convert from long to int;
		//说明JVM首先检查右边的第一个直接数是否有效(这里其实就是检查是否超出Int范围),结果报了第一个错;接下来检查它是否与等号左边的类型符合赋值条件(也就是它是否小于等于左边的类型),符合则检查连接符号的后面一个数的有效性,是否满足赋值条件;此例中由于连接符号的后一个数1L虽然具有有效性,因为它被视为Long型数据,但是它没有满足赋值条件,因此报了第二个编译错误;
		
		// 2：a =1L+2147483648;     先报编译错：Type mismatch: cannot convert from long to int;
		                                //再是:The literal 2147483648 of type int is out of range;
		//通过分析第一次赋值的说明,就很容易得出为什么第二次赋值的报错顺序和前一次不同了;
		//////////////////////////////////////////////////////////////////////
		
		byte k4 =(byte)128;    //这里相当于把int类型的128强转为byte类型,发生溢出,得到负数,但是通过了编译,很好的证明了上例的假设;
		//static int z = 1;  这里会报错，因为在方法中无法声明静态变量，方法中的变量作用域只在方法中，如果声明为静态的,相当于
		//可以跳过方法用类直接调用,显然是不行的;
		int max = 0x7fffffff;
		long a = max +1 ;   //因为max和1都为int类型，会按照int相加，结果已经溢出，再把溢出后的int类型数赋给右边的long类型,向上转类型,所以a输出为long形式的int的最小值：-2147483648;
		a = max + 1L;       //由于出现“1L”，系统会向上转型，会先把max转换为long然后+1，结果以long形式正常输出;
		System.out.println(a);    
		
		//long t1 = 2147483648;  //这里会报错out of range ,虽然用立即数给一个变量赋值,如果次数在这个变量的类型范围内,会直接按照这个类型赋值,但是这只限于给int类型以下类型赋值时,因为如果这个立即数超出了int范围就会直接报超范围错误,所以想要成功赋值就需要标记此直接数为long类型; 
		//long t2 = (long)2147483648; //仍旧报错,因为强转都是针对向下转的,向上只要符合条件不需要强转就能赋值;
		long t3 = 2147483648L;
		
		char c = 'c';
	    c = 97;       //char类型为16位无符号整数0-65535，其中一些字符不能被通用计算机识别;
	    //a=97；A=65
	    //z=122；Z=90
	    
	    //c = c+c;  这里会报错：不能将int类型的数转换为char;
	    short d = 2;
	    //d=d+d;   这里也会报错：不能将int类型的数转换为short;
	    
	    //原因是：如果使用+,-,*,/,%,&,|,^,<<,<<<,>>这样的运算符号链接,JVM会默认2个原本类型低于int的整数为2个或多个int数相加(如果等号右边只有一个单独的整型变量,则jvm视其为它自身的类型来与等号左边比较;),而int不能转换为比他低类型的整数！
	    //注意：当2个不同类型的数相加,会自动先向上转型再相加,结果类型为较高级的类型!
	    
	    c = (char)(c+c); //通过强转可以实现 ;
	    c = 'a'+'a';     //注意，和String类不同的是，+号不能链接两个字符;
	    c = 'a'+ 1;      //这条语句与上一条语句都不会报错的原因是，java程序在编译期间自动将字面量与常量的计算优化为其运算结果的
	    				 //立即数并替代，而变量的运算在运行期间执行！编译期优化的目的是提高运行效率，为运行期间少了一些事先可以解决
	                     //的运算;
	    c = 'a'+ Z;      //这里就是字面量与常量在编译时被优化 (在此处常量的概念就是用final修饰的变量);
	    
	    String s = "a"+"a"; //这里的+号属于运算符的重载，java中只有一个运算符存在重载，就是+!
	    
	    String b = "123";
	    System.out.println(c+b);    //b123    这里的+号属于运算符的重载，java中只有一个运算符存在重载，就是+!
	    System.out.println(c+c+b);  //196123 这里输出结果不同是因为，系统一次只能做一个运算，有没有括号加权，会默认从左往右,
	    //先计算c+c时，会默认为2个int相加;

	    char c1=1;
	    short s1=2;
	    //c1=s1;
	    //s1=c1;
	    //以上两式都会报错,分别为can not convert from short to char; can not conver from char to short;
	    //它们虽然分别都是16位整数(char 是16位无符号整数 0~~65535; short 是16位有符号整数 -32768~~32767),但是它们互相赋值时必须强转;
	    
	    //在得到80% 也就是0.8这样的数时，有些注意点：
	    float f = 80/100;       //输出结果是0.0，这里是整除，int类型自动向上转成float类型;
	    double ff = 80D/100;    //这里80D相当于向上转型为double 8.0，浮点数的除法不是整除是直接的除法运算!
	    double fff = 3%7;       //整除结果为0，其余数就是被除数本身;
	    System.out.println(f);
	    System.out.println(ff);
	    System.out.println(fff);
	    
	    //关于a++及其相关内容的注意点：
	    int a1=1;
	    a1 = a1++;
	    System.out.println(a1); //结果为1!
	    //a++运算的步骤!
	    //1.先去a1=1 赋给a1++
	    //2.a1的值自增1，a1=2
	    //3.将a1++的值赋给a1，结果a1=1!
	    
	    int a2=1;
	    a2 = ++a2;
	    System.out.println(a2);//2，这个比较简单，先把a2+1的值赋给++a2，然后a2自身+1变为2，最后再将++a的值赋给a2;
	    System.out.println(k3);
	    
	    //关于逗号表达式与“++”或“--”的连用,还有一个比较好的例子：
	    a=1;
	    System.out.println(a++); //1;
	    
	    a=1;
	    System.out.println(a++-a); //-1;
	    
	    
	}
}



