HideOverloadOverrideAndDynamicBindin 

隐藏重载覆写和动态绑定


package prototype;

public class SongHideOverloadOverrideAndDynamicBinding {
	public static void main(String[] args) {
		Father1 s=new Son1(); //向上转型;
		   System.out.println(s.a); //向上转型后的s对象调用的参数a输出了隐藏在子类中的父类属性a=1;与调用覆写过的父类非静态方法不同的是：非静态方法并不存在隐藏现象，向上转型后，s在编译时被标记为父类的元素，但是指向子类的堆内存，导致了在调用覆写过的父类非静态方法时，子类堆内存中的用于方法调用的地址直接指向方法区子类的信息块，而被调用的方法名称也确实在父类信息块中存在，与编译时s对象绑定的父类信息相符，所以就直接能调用此子类信息块中的覆写过的非静态方法了;  
		   s.f();                   //向上转型调用了一个静态方法，虽然子类“覆写”了此静态方法，但是由于静态方法存在“继承”和“隐藏”(因为覆盖是动态绑定，是受RTTI(run time type identification，运行时类型检查)约束的，隐藏不受RTTI约束，RTTI只针对覆盖，不针对隐藏,因此对象在调用方法时会直接根据编译时绑定的类型在堆中寻找此类在方法区的信息地址一遍调用其中的同名方法)，这点得益于在堆中包括能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些数据类型存储在方法区中。也就是说子类的内存中关于这个静态方法的信息让调用此方法的对象直接去它的编译时绑定的类的方法区信息块中寻找同名方法（静态代表了是属于一个类的，而不是单个对象），而不是像之前调用非静态方法时堆中的方法信息会让调用方法对象先去此堆内存隶属的类（也就是子类）的方法区信息块找同名方法，找到就直接调用，找不到再通过堆中信息找到父类在方法区的信息块调用其同名方法;
		   Son1 s2=new Son1();
		   System.out.println(s2.a);//子类对象的a当然输出的是子类中的属性a=2;
		   s2.f();                  //子类对象调用其静态方法是"覆写"过的属于自己的静态方法;
	}
}
class Son1 extends Father1{
	public static void f(){         //如果把这里子类”覆写“的静态方法删除，main()中s2.f();会调用父类的静态方法，说明子类确实继承了父类的静态方法，只是如果去”覆写“此方法的话，就相当于子类添加了一个属于自己的扩展静态方法;
		System.out.println("子类的静态方法！");
	}
	int a =2;//如果这里未声明int a=2,那么main()中的s2.a将会调用继承下来并且隐藏了的父类属性a=1;
	////////////////////
	public Son1 f2(){               //对比父类的f2();方法然后参见补充第3条;
		return new Son1();
	}
}
class Father1{
	int a =1;
	public static void f(){
		System.out.println("父类的静态方法！");
	}
	///////////////////////
	Father1 f2(){
		return new Father1();
	}
}


/*补充：

1.其实”隐藏“是C++的一种属性,严格意义上讲,JAVA只有重载,覆写,并没有隐藏,但是此处的2个例子（继承下来的参数和静态方法）确实具有隐藏的特性;

2.重载：(1)方法名相同，但参数不同的多个同名函数;(2)返回值和异常以及访问修饰符可以不同也可以相同;(3)main方法也是可以被重载的

3.覆盖：(1)子类重写父类的方法，要求方法名和参数类型完全一样;(2)返回值和异常比父类小或者相同;(3)访问修饰符比父类大或者相同;

注意：子类实例方法不能覆盖父类的静态方法（This instance method cannot override the static method from Parent）编译时报错:子类的静态方法也不能覆盖父类的实例方法（This static method cannot hide the instance method from Parent）(编译时报错)，总结为方法不能交叉覆盖; 
注：jdk解释为静态方法不能隐藏父类的实例方法; 因为,static是方法的一种属性,并非访问权限,这种方法的属性只能被子类继承而不能被改变,所以子类既无法以非静态形式覆写父类的静态方法,又无法以静态形式覆写父类的非静态方法,如果这样编写编译阶段就会报错,说明java禁止了这种前后不一致的行为; 而对父类/子类中同名的static属性的声明不存在这样的限制;
	  
4.隐藏：父类和子类拥有相同名字的属性或者方法时(前提是子类成功的继承了这些方法和属性),父类的同名的属性或者方法形式上不见了,也就是说它们只能被父类来访问了,继承性"丢失"了;
注意： (1)当发生隐藏的时候,声明时类型是什么类,就调用对应类的属性或者方法,而不会发生动态绑定;
      (2)方法隐藏只有一种形式,就是父类和子类存在相同的静态方法;
      (3)属性只能被隐藏,不能被覆盖;
      (4)因为覆盖是动态绑定,是受RTTI(run time type identification,运行时类型检查)约束的,隐藏不受RTTI约束,总结为RTTI只针对覆盖,不针对隐藏;

注：RTTI（Run-Time Type Identification,运行时刻类型识别）允许“用指向基类的指针或引用来操纵对象”的程序能够获取到“这些指针或引用所指对象”的实际派生类型;

5.动态绑定:
所谓RTTI其实就是一种动态绑定机制,绑定分为静态绑定和动态绑定,或者叫做前期绑定和后期绑定;
静态绑定为程序编译期的绑定;动态绑定是在运行时根据具体对象的类型进行绑定;
java当中的方法只有final,static,private和构造方法是前期绑定,其他都是动态绑定,java中的动态绑定是由JVM来实现的,我们不用去显式的声明它,而C++则不同,必须明确的声明某个方法具备后期绑定的能力;
java当中的向上转型或者说多态是借助于动态绑定机制而实现的;


流程:
(编译的过程同时也相当于一个对将要被执行语句合法性验证的过程);

编译阶段:

father s = new son();
编译器将s对象father类标记绑定,并且验证son类中确实存在父类father的信息,这条语句通过编译;

s.sonMethod();
由于之前s对象被编译器绑定为father类的,所以这里在father类中寻找sonMethod()方法信息,假设此方法是son类的扩张方法,则此处无法在father类中找到此方法的信息,编译报错!

s.fatherMethod();
假设fatherMethod()为son类覆写father类中的非static,final,private方法,满足动态绑定条件,编译器成功找到此方法信息,编译通过,并且标记为运行时绑定;

如果此方法是父类static,final,private标记的方法,则通过编译并且静态绑定为father类的方法,在运行时将在调用对象的栈空间中直接去寻找father类地址信息并在方法区查找调用该方法;


运行阶段:

father s = new son();
JVM创建son类实例,分配空间,将地址赋给s对象;

s.fatherMethod();
由于在编译阶段被标记为动态绑定,此处JVM将先找到s对象指向的空间,也就是子类空间,在其中查找这个同名方法,找不到再从空间中保存的指向父类信息块中找同名方法调用;很显然在这个阶段默认视为子类调用方法的过程,因为是在子类实例化的空间查找的,这就完成了动态绑定;

如果此处是静态绑定的方法呢,则JVM将直接在s对象指向空间中查找父类信息块地址并前往方法区寻找同名方法,相当于编译期间为此方法添加了"super."标记;

这就是多态的实现,得益于了动态绑定机制;




*/



